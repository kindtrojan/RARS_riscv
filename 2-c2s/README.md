<!-- MASTER-ONLY: DO NOT MODIFY THIS FILE

Copyright © Telecom Paris
Copyright © Renaud Pacalet (renaud.pacalet@telecom-paris.fr)

This file must be used under the terms of the CeCILL. This source
file is licensed as described in the file COPYING, which you should
have received as part of this distribution. The terms are also
available at:
http://www.cecill.info/licences/Licence_CeCILL_V1.1-US.txt
-->

C compilation and assembly analysis

---

[TOC]

---

As for any lab do not forget to write a report in [Markdown syntax] in the `REPORT.md` file.
Remember that the written reports and source code are personal work (plagiarism is not accepted).
Do all assignments yourself and try to understand each of them.
You can of course discuss with others, exchange ideas, ask others for help, help others…
It is even warmly recommended, but at the end your report and source code must be your personal work.
They are due the day before the written exam at 23:59.
After this deadline the git repository will become read-only and there will be no possibility any more to add or modify something.

## Set-up

1. Open a terminal, change the working directory to the `ca` clone, check the current status (`USERNAME` represents your username, that is, the name you use to log on Eurecom GNU/Linux desktop computers):

    ```bash
    $ cd ~/Documents/ca
    $ git status
    On branch USERNAME
    Your branch is up to date with 'origin/USERNAME'.
    
    nothing to commit, working tree clean
    ```

1. If the current branch is not your personal branch, switch to your personal branch and check again the current status:

    ```bash
    $ git checkout USERNAME
    $ git status
    …
    ```

1. If your branch is not up to date with `origin/USERNAME` or there is something to commit or the working tree is not clean, add, commit and/or pull until everything is in order.

1. Pull, merge with `origin/master`, change the working directory to this lab's directory and list the directory's content:

    ```bash
    $ git pull
    $ git merge origin/master
    $ cd labs/2-c2s
    $ ls
    README.md
    REPORT.md
    abssub.c
    recurse.c
    ```

   `README.md` is the file you are currently looking at, `REPORT.md` is the empty file in which you will write your lab report, `abssub.c` and `recurse.c` are empty files in which you will write C code.

1. Source the `/packages/LabSoC/bin/ca_functions` script to define the `rars` and `c2rv` bash functions:

    ```bash
    $ source /packages/LabSoC/bin/ca_functions
    ```

   Remember that these definitions are for the current terminal only.
   If you open a new terminal source the script again.

## Introduction

In this lab we will have a look at a simple C program, compile it with the `gcc` C compiler and run it on our real computer.
Then, we will also compile it for a RISC-V hardware target and analyze the RISC-V assembly code generated by the compiler.
As we are working on a PC which microprocessor is a x86\_64 processor, not a RISC-V processor, we will use a version of `gcc` that compiles for a different hardware target (RISC-V) than the one it runs on (x86\_64).
This is what is called a cross-compiler.
Ours is `/packages/LabSoC/riscv/bin/riscv32-unknown-linux-gnu-gcc`.
The `c2rv` bash function will hide the details but it is good to know what it really does.
Here is how it is declared in the script that you sourced:

```bash
c2rv() {
    /packages/LabSoC/riscv/bin/riscv32-unknown-linux-gnu-gcc -march=rv32im -mabi=ilp32 -S "$@"
}
```

The `-march=rv32im` option specifies the target Instruction Set Architecture (ISA): the RISC-V 32 bits integer with multiply and divide extension (RV32IM for short).
`-mabi=ilp32` specifies the Application Binary Interface (ABI), that is, the set of conventions about registers usage, stack usage, function calls, etc.
Our ABI is the Integer-Long-Pointer-32-bits (ILP32 for short).
By default the compiler produces a binary executable for a RISC-V processor, but this is not convenient to analyze; the `-S` option asks the compiler to generate the much more human-readable assembly source code and to stop there.
The final `"$@"` will be replaced by all extra parameters that you will add after `c2rv`.

We will also play with the optimization options of the C compiler and observe their effect on the generated assembly code.
Finally we will adapt the generated assembly code such that it can run on the virtual RISC-V computer that RARS emulates, and we will run it.

In the generated assembly code you will see more information than what we really need.
You can safely ignore most assembler directives (directives start with a dot), except:

* `.text`: indicates the beginning of a code section
* `.data`: indicates the beginning of a data section
* `.section .rodata`: indicates the beginning of a read-only data section (constant data).
* `.globl LABEL`: indicates that the `LABEL` label is exported to other modules (and will be used by the linker when it will merge all generated binaries in one single executable)
* `.string`: an alias for `.asciz` that we already encountered in the first lab.
* `.align n`: forces the assembler to align the following items in memory on a $`2^n`$ boundary.

## Edit C source file, compile and run

### C coding

1. Use your favorite text editor to open the `abssub.c` source file.
   First include the `stdio.h` header file; it declares the `printf` library function that we will use to print messages:

    ```c
    #include <stdio.h>
    ```

1. Next, declare and define a `printInt` function that prints its integer parameter (`val`), followed by a newline character, and returns nothing (`void`):

    ```c
    void printInt(int val) {
        printf("%d\n", val);
    }
    ```

  > Note: this `printf` instruction prints the value of variable `val` considered as an integer (`%d`), followed by a newline (`\n`).

1. Then, declare and define a `absSub` function that takes two integer parameters (`a` and `b`), computes the `b - a` subtraction, the absolute value of the result, and returns it.

    ```c
    int absSub(int a, int b) {
        int c;
    
        c = b - a;
        if(c < 0) {
            c = -c;
        }
        return c;
    }
    ```

1. Finally, declare and define a `main` program that takes no parameters (`void`), calls our two functions to print the result of `absSub(17, 46)`, and returns integer 0:

    ```c
    int main(void) {
        printInt(absSub(17, 46));
        return 0;
    }
    ```

1. Save the file.

### C compilation and execution on the host PC

What do you think will happen if we compile this C program for our host PC and run it?
Check your answer:

```bash
$ gcc -o abssub abssub.c
$ ./abssub
```

### C compilation to RISC-V assembly

1. Compile `abssub.c` for the RV32IM target:

    ```bash
    $ c2rv abssub.c
    ```

1. Look at the `abssub` function in the `abssub.s` produced assembly code.
   Try to answer the following questions. If you do not understand a term or a complete question, search by yourself and discuss your understanding with your neighbors.
   * What is the size of the stack it uses?
   * What is the stack used for?
   * What registers are saved on the stack at the beginning and restored from the stack at the end?
   * Two registers are used to manage the stack and to access its content, which ones?
   * What are they used for?
   * Are there input parameters in this function and, if yes, in what registers are they passed?
   * Are there output results and, if yes, in what registers are they passed?
   * Try to understand the code.
     Does it look correct?
   * Do you think the code could be optimized?

1. Look at the `main` function in the `abssub.s` produced assembly code:
   * Answer the same questions as for the `abssub` function
   * Do you see where the `main` function calls the `abssub` function?
   * Do you think the compiler uses a kind of calling convention similar to the one we studied during the lectures?
   * Try to summarize the strategy that the compiler uses to call functions:
     + What is done in the caller before the function is called?
     + What is done at the beginning of the callee?
     + What is done at the end of the callee?
     + What is done in the caller after returning from the callee?
     + What registers are preserved by the callee and what registers are not?

1. A recursive function is a function that calls itself.
   Recursive functions are sometimes a convenient way to code an algorithm.
   Example of recursive function:

    ```c
    // returns n-th element of Fibonacci series
    unsigned int fibonacci(unsigned int n) {
      if(n == 0) return 0;
      if(n == 1) return 1;
      return fibonacci(n - 1) + fibonacci(n - 2);
    }
    ```

   Do you think the conventions used by the compiler and seen during the lectures would work with recursive functions?
   Why?
   If yes, do you think there is a limit to the number of recursions?
   Why?

1. Let's try.
   Knowing that `scanf` does the opposite of `printf` (read from the keyboard instead of printing on the screen) and that the local variables of a function are allocated in the stack by the function, try to understand the following C code:

    ```c
    #include <stdio.h>
    
    void recurse(int iteration) {
      int dummy[10];
    
      if(iteration == 0) {
        return;
      }
      recurse(iteration - 1);
    }
    
    int main(void) {
      int i;
    
      printf("The size of an int is %lu bytes\n", sizeof(int));
      printf("Please enter a number of iterations: ");
      scanf("%d", &i);
      recurse(i);
      return 0;
    }
    ```

   Use your favorite text editor to open the `recurse.c` source file and copy-paste the above C code in it.
   Compile it:

    ```bash
    $ gcc -o recurse recurse.c
    ```

   Run it with 1000 iterations:

    ```bash
    $ ./recurse
    The size of an int is 4 bytes
    Please enter a number of iterations: 1000
    ```

   Try again with 10000, 100000, etc.
   Can you explain what happens with a large enough number of iterations?
   What is the approximate maximum size of the stack on your host PC?

### Optimization

1. Compile again `abssub.c` for the RV32IM target, but with maximum optimization, this time:

    ```bash
    $ c2rv -O3 -o abssub.o3.s abssub.c
    ```

1. Look at the produced assembly code in `abssub.o3.s`:
   * Do you think the compiler did a good optimization job?
   * Do you think the code could be further optimized?

## Adaptation for RARS, assembly, simulation

### Adaptation for RARS

1. Launch RARS (just type `rars`), open the `Settings` menu and configure it according the following picture:

   ![RARS settings](../../doc/rars-settings.png)

1. There are two small things to modify in the generated assembly code before we can simulate it with RARS:

   1. RARS does not know anything about the standard C library and its `printf` function.
      Open `abssub.s` and replace the call to `printf` by a system call.

   1. The compiler assumes that our `main` function is called by some startup code and that it shall return to it when finished.
      In RARS there is no such startup code so when returning `main` will use an invalid return address and RARS will complain.
      In `main` replace the return to caller by the `Exit` system call.

### Assembly

1. Assemble the code (`[Run -> Assemble]`).
   You can ignore the warnings about the directives that RARS does not recognize.
   If there are errors fix them, save the file and assemble again until the operation completes successfully.

1. Observe the data segment in the `Data Segment` sub-window.
   What does it contain?
   You can toggle the `ASCII` and `Hexadecimal` radio-buttons to show the data in the most convenient form.
   Can you identify the parts of the assembly source code that produced this data segment?

1. Observe the text segment in the `Text Segment` sub-window.
   What basic instructions are used to implement the `call` pseudo-instruction?
   Convince yourself that they do the same as the `call` they implement.

### Simulation

It's time to test this application (`[Run -> Go]`).
The output messages are sent to the `Run I/O` tab of the bottom RARS sub-window.
If the application does not behave as expected try to understand where it comes from and try to fix it.

### Step by step execution

1. Reset the simulator (`[Run -> Reset]`).

1. Execute step-by-step (`[Run -> Step]`) and observe the changes in the registers and in the data segment.

1. Try to really understand the function calls, the registers and stack usage.
   At the end of this lab you should be able to write a function in assembly using the same ABI, and to call it.

## Report, add, commit, push

Once you will have written your report do not forget to add, commit and push it in your personal branch.
Add also the `abssub.s` file.

[Markdown syntax]: https://www.markdowntutorial.com/

<!-- vim: set tabstop=4 softtabstop=4 shiftwidth=4 expandtab textwidth=0 syntax=markdown: -->
